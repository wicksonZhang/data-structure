# 红黑树

> 本章节代码：https://github.com/wicksonZhang/data-structure/tree/main/8-RedBlackTree

## 基础知识

### 什么是红黑树

* 红黑树是在 `AVL` 树和 `B` 树基础上面进行发展而来的，所以红黑树也是一种自平衡的二叉搜索树。

  <img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312272046577.png" alt="image-20231227204630559" style="zoom:100%;float:left" />



### 红黑树优缺点

**优点**

* **平衡性：**红黑树是基于二叉查找树（`BST`）的一种改进和扩展，这也确保了树的高度不会过高。
* **高效的插入和删除：**红黑树主要还是基于 `AVL` 和 `B` 两种数据结构进行历史演进而来，红黑树解决了 `AVL` 频繁插入、删除的问题。所以使得插入、删除和搜索等操作的时间复杂度可以保持在对数级别（O(log n)）。



**缺点**

* **复杂性：**红黑树结合了 `B` 树和 `AVL` 树的特性，导致添加和删除时需要涉及到元素的左旋和右旋，这也使得了红黑树的实现和理解稍微复杂一些。



### 红黑树解决了什么问题

**红黑树主要解决了二叉查找树可能出现的不平衡性问题**。

* 二叉查找树的不平衡可能会导致性能退化，使得搜索、插入和删除等操作的时间复杂度从理想的 **O(log n)** 变为最坏情况下的 **O(n)**



🤔`AVL` 树也解决了二叉搜索树可能出现的不平衡问题， 红黑树相比于 `AVL` 树又做了哪些优化呢？

* 平衡调整的频率
  * `AVL` 树在频繁的插入和删除时会导致整棵树进行频繁的调整，这也需要更多的旋转操作，这会导致整棵树的性能下降。
  * `红黑树` 红黑树采用通过颜色标记和一系列的平衡规则来确保整棵树的平衡，尤其是涉及到大量的插入和删除操作时尤为明显。



### 生活中对应的场景

* `java` 中的 `HashMap` 、`TreeMap` 集合就采用到了红黑树。



## 红黑树的基本特性（重要）

### 红黑树的性质

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312272046577.png" alt="image-20231227204630559" style="zoom:100%;float:left" />

**红黑树必须满足以下 5 条性质**

1. 节点是 **`Red`** 或者 **Black**
2. 根节点是 **Black**
3. 叶子节点（外部节点、空节点） 都是 **Black**
4. **`Red`** 节点的子节点都是 **Black**
   1. **`Red`** 节点的 parent 都是 **Black**
   2. 根节点到叶子节点的所有路径上不能又 2 个连续的 **`Red`** 节点
5. 从任意节点到 叶子节点 的所有路径都包含相同数据的 **Black** 节点



### 红黑树的等价交换

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312272207977.png" alt="image-20231227220740921" style="zoom:80%;float:left" />

* 红黑树 和 4阶B树（2-3-4 树）具有等价性。
* **Black** 和 **`Red`** 子节点融合在一起可以形成一个B树节点。

* 红黑树的 **Black** 节点个数与 4阶B树 的节点总个数相等。



## 红黑树的实现

### `UML` 类图





### 代码实现

#### 构造器

> 上面已经说过了红黑树是来源于 `AVL` 树和 `B` 树，所以我们的代码还是基于二叉树进行开发。

```java
/**
 * 红黑树
 */
public class RedBlackTree<E> extends BST<E> {

    public RedBlackTree() {
        this(null);
    }

    public RedBlackTree(Comparator<E> comparator) {
        super(comparator);
    }
    
    // 红色节点
    private static final boolean RED = false;

    // 黑色节点
    private static final boolean BLACK = true;
    
    /**
     * 红黑树节点
     *
     * @param <E>
     */
    private static class RedBlackNode<E> extends Node<E> {
        boolean color = RED;

        public RedBlackNode(E element, Node<E> parentNode) {
            super(element, parentNode);
        }
    }

}
```



#### 红黑树的辅助节点

> 基于上面的构造器的信息，但是我们针对红黑树也有一些定制化的开发。

* 红黑树的辅助节点代码
  * 对添加的节点进行染色
  * 添加红色或者黑色节点
  * 判断红黑树节点的颜色
  * 

##### 对添加的节点进行染色

* 我们对添加的节点进行染色时，需要将 `BST` 的节点强制转换红黑树的节点进行染色。

```java
    /**
     * 对添加节点进行染色
     *
     * @param node  节点
     * @param color 颜色
     * @return Node<E>
     */
    private Node<E> color(Node<E> node, boolean color) {
        if (node == null) return null;

        ((RedBlackNode<E>) node).color = color;
        return node;
    }
```

##### 添加红色或者黑色节点

* 我们基于 `对添加的节点进行染色` 代码进行扩展，可以添加红色节点或者添加黑色节点。

```java
    /**
     * 添加红色节点
     *
     * @param node 节点
     * @return Node<E>
     */
    private Node<E> red(Node<E> node) {
        return color(node, RED);
    }

    /**
     * 添加黑色节点
     *
     * @param node 节点
     * @return Node<E>
     */
    private Node<E> black(Node<E> node) {
        return color(node, BLACK);
    }
```

##### 判断红黑树节点的颜色

```java
    /**
     * 判断红黑树节点的颜色
     *
     * @param node 节点
     * @return boolean
     */
    private boolean colorOf(Node<E> node) {
        return node == null ? BLACK : ((RedBlackNode<E>) node).color;
    }

    /**
     * 判断是否是红色节点
     *
     * @param node 节点
     * @return boolean
     */
    private boolean isRed(Node<E> node) {
        return colorOf(node) == RED;
    }

    /**
     * 判断是否是红色节点
     *
     * @param node 节点
     * @return boolean
     */
    private boolean isBlack(Node<E> node) {
        return colorOf(node) == BLACK;
    }
```

##### 返回当前节点的兄弟节点

* 该方法是在 `BinaryTree` 中 `Node<E>` 进行添加

```java
        /**
         * 兄弟节点
         *
         * @return Node<E>
         */
        public Node<E> sibling() {
            if (isLeftChild()) {
                return parentNode.rightNode;
            }
            if (isRightChild()) {
                return parentNode.leftNode;
            }
            return null;
        }
```





### 单元测试





















