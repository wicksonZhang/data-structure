# 映射（Map）

> 本章节代码：https://github.com/wicksonZhang/data-structure/tree/main/10-Map

## 基础知识

### Map 解决了什么问题？

​		例如，我们在全国的行政区划表中，需要通过 行政区划 Code 找到对应的 Name 名称 , 如果使用的是数组进行存储的话，我们需要找到某个元素，可能是从头找到尾，时间复杂度可能为O(n)，这会导致效率会特别低。

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401152349766.png" alt="image-20240115234920722" style="zoom:100%;float:left" />

* 如果使用数组实现代码如下
  * 最好的情况可能是 O(1)，最坏的情况是 O(n)，平均时间复杂度为 O(n)

```java
// 使用List存储地址信息
List<DivisionInfo> divisionInfos = new ArrayList<>();
divisionInfos.add(new DivisionInfo(110000 "北京"));
divisionInfos.add(new DivisionInfo(120000, "天津"));
divisionInfos.add(new DivisionInfo(130000, "河北省"));
String name = "";
divisionInfos.forEach(divisionInfo -> {
    if (11000 == divisionInfo.getNumberCode()) {
        name = divisionInfo.getName();
        break;
    }
});
```

* 如果使用映射Map实现的代码如下
  * 如果我们底层采用的红黑树，最好的情况O(logn)，最坏的情况O(logn)

```java
Map<Integer, DivisionInfo> map = new HashMap<>();
map.put(110000, new DivisionInfo(110000 "北京"));
map.put(120000, new DivisionInfo(120000, "天津"));
map.put(130000, new DivisionInfo(130000, "河北省"));
// 直接通过Map获取信息
DivisionInfo divisionInfo = map.get(110000);
```



### Map 是什么？

* 在数据结构中，映射（Mapping）是一种将键（Key）与值（Value）关联起来的结构，也被称为字典、哈希表或关联数组，具体的实现方式有很多种。

  

### Map 优缺点





### Map 应用场景





## Map 接口设计

### UML 类图



### 接口设计

```java
public interface Map<K, V> {

    int size(); // 元素数量

    boolean isEmpty(); // 集合是否为空

    void clear(); // 清除所有元素

    V put(K key, V value); // 添加元素

    V get(K key); // 获取元素

    V remove(K key); // 删除元素

    boolean containKey(K key); // 是否包含Key

    boolean containValue(V value); // 是否包含Value

    void traversal(Visitor<K, V> visitor); // 遍历集合

    public static abstract class Visitor<K, V> {
        public boolean stop;

        public abstract boolean visit(K key, V value);
    }

}
```



## Map 具体实现

### Node节点初始化

```java
/**
 * 基于红黑树实现映射
 *
 * @param <K>
 * @param <V>
 */
public class TreeMap<K, V> implements Map<K, V> {
    
    // TODO
    
	// 节点为红色
    private static final boolean RED = false;

    // 节点为黑色
    private static final boolean BLACK = true;

    /**
     * Node<K, V> 节点实现
     *
     * @param <K> key
     * @param <V> value
     */
    private static class Node<K, V> {
        // Key
        K key;

        // value
        V value;

        boolean color = RED;

        // 左子节点
        Node<K, V> leftNode;

        // 右子节点
        Node<K, V> rightNode;

        // 父级节点
        Node<K, V> parentNode;

        public Node(K key, V value, Node<K, V> parentNode) {
            this.key = key;
            this.value = value;
            this.parentNode = parentNode;
        }

        /**
         * 是否存在叶子节点
         *
         * @return boolean
         */
        public boolean isLeaf() {
            return leftNode == null && rightNode == null;
        }

        /**
         * 是否该节点的度为2
         *
         * @return boolean
         */
        public boolean hasTwoChildren() {
            return leftNode != null && rightNode != null;
        }

        /**
         * 是否是左子树
         *
         * @return boolean
         */
        public boolean isLeftChild() {
            return parentNode != null && this == parentNode.leftNode;
        }

        /**
         * 是否是右子树
         *
         * @return boolean
         */
        public boolean isRightChild() {
            return parentNode != null && this == parentNode.rightNode;
        }

        /**
         * 兄弟节点
         *
         * @return Node<E>
         */
        public Node<K, V> sibling() {
            if (isLeftChild()) {
                return parentNode.rightNode;
            }
            if (isRightChild()) {
                return parentNode.leftNode;
            }
            return null;
        }

    }

}
```

