# 二叉堆

> 本章节代码：

## 基础知识

### 二叉堆解决了什么问题

二叉堆解决的主要问题是在一个动态集合中找到最大或最小元素，并且支持快速的插入和删除操作。

* 找到最大或最小元素的时间复杂度：O(1)
* 删除和插入的时间复杂度：O(logn)



### 二叉堆是什么

**二叉堆（Binary Heap）：**二叉堆是一种特殊的二叉树数据结构，二叉堆的核心概念如下：

* **堆（heap）：**任意节点 i 的值总是 **大于等于（>=） 或者 小于等于（<=） 子节点** 的值。
* **最大堆（Max Heap）：** 对于任意节点 i 的值如果 **大于等于（>=） 子节点** 的值。
* **最小堆（Min Heap）：**对于任意节点 i 的值如果 **小于等于（<=）子节点** 的值。

![image-20240131214432923](https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401312144073.png)



### 二叉堆的性质

二叉堆的本质上是一颗完全二叉树，所以二叉堆的索引 i 具备以下性质：

* **注意，以下的 i 代表的是索引，n 代表的是元素数量**。
* 如果 **i = 0**，它是根节点。例如，节点 72.
* 如果 **i > 0**，它的父节点的索引为 **floor((i - 1) / 2)**。例如，节点 43、38 的父节点都是 68。 **floor((3 - 1) / 2) = 1**
* 如果 **2i + 1 <= n - 1**，它的左子节点的索引为 **2i + 1**。例如，节点 68 的左子节点 43。**2 * 1 + 1 = 3**
* 如果 **2i + 1 > n - 1**，它无左子节点。例如，节点 47 无左子节点。**2 * 5 + 1 > 10 -1**
* 如果 **2i + 2 <= n - 1**，它的右子节点的索引为 **2i + 2**。例如，节点 68 的右子节点就是 38。**2 * 1 + 2 = 4**
* 如果 2i + 2 > n - 1，它无右子节点。例如，节点47。**2 * 5 + 2 > 10 - 1**

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401312153351.png" alt="image-20240131215306300" style="zoom:80%;float:left" />



### 二叉堆优缺点

**优点**

* **高效的插入和删除操作：** 二叉堆对于插入和删除操作的时间复杂度都是 O(log n)，其中 n 是堆中元素的数量。
* **高效的查找最大值或最小值：**如果是最大堆或者是最小堆，根节点就是最大值或者最小值，时间复杂度为O(1)。

**缺点**

* **不支持动态大小：**因为二叉堆一般底层可以采用数组实现，所以是不具备动态扩容的。



## 二叉堆的实现

### `UML` 类图





### 接口设计

* 如下是堆 **Heap** 的接口设计

```java
/**
 * 堆
 *
 * @param <E>
 */
public interface Heap<E> {

    // 元素的数量
    int size();

    // 是否为空
    boolean isEmpty();

    // 清空元素
    void clear();

    // 添加元素
    void add(E e);

    // 获取堆顶元素
    E get();

    // 删除堆顶元素
    E remove();

    // 替换元素
    E replace(E e);

}
```



### 代码实现

```
1. 初始化元素
2. 元素的数量
3. 是否为空
```



#### 初始化元素

```java
/**
 * 二叉堆
 *
 * @param <E>
 */
@SuppressWarnings("unchecked")
public class BinaryHeap<E> implements Heap<E> {

    // 数组元素
    private E[] elements;

    // 元素数量
    private int size;

    // 默认初始容量
    private static final int DEFAULT_CAPACITY = 1 << 4;

    // 二叉堆是具有可比较性的
    private Comparator<E> comparator;

    public BinaryHeap() {
        this(null);
    }

    public BinaryHeap(Comparator<E> comparator) {
        this.comparator = comparator;
        this.elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    /**
     * 二叉堆一定是具有可比较性的
     *
     * @param element1 元素1
     * @param element2 元素2
     * @return int
     */
    private int compare(E element1, E element2) {
        if (comparator != null) {
            return comparator.compare(element1, element2);
        }
        return ((Comparable<E>) element1).compareTo(element2);
    }

}
```



#### 元素的数量

```java
    @Override
    public int size() {
        return size;
    }
```



#### 是否为空

```java
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
```



#### 清空元素

```java
    @Override
    public void clear() {
        if (size == 0) {
            return;
        }
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
    }
```



#### 获取堆顶元素

```java
    @Override
    public E get() {
        emptyCheck();
        return elements[0];
    }

    private void emptyCheck() {
        if (size == 0) {
            throw new IndexOutOfBoundsException("Heap is empty");
        }
    }
```



#### 添加元素
