# 二叉搜索树

> 本章节的代码：https://github.com/wicksonZhang/data-structure/tree/main/6-BST

## 基础知识

### 什么是二叉搜索树

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312010951236.png" alt="image-20231201095154187" style="zoom:80%;float:left" />

* 二叉搜索树（Binary Search Tree，`BST`）：二叉搜索树是二叉树的一种，二叉搜索树中每个节点中最多有两个子节点：左子节点和右子节点。
  * 其中任意一个节点的值都要 **大于** 其左子树所有节点的值
  * 其中任意一个节点的值都要 **小于** 其右子树所有节点的值
  * 它的左右子树也是一颗二叉搜索树

* 注意：二叉搜索树中存储的元素必须具备可比较性，且不允许为 null



### 二叉搜索树解决了什么问题

* 如果从数组的角度进行考虑，数组如果添加、删除、查找元素的话，最好可能是O（1），最坏的情况可能是O（n），平均是O（n）。
* 但二叉搜索树就进一步的解决了这个问题：
  * **高效查找**：由于其有序性质，可以利用二分搜索的方式快速定位到所需的节点，平均时间复杂度为 O(log n)。
  * **有序性：** `BST` 中的节点按照特定的顺序排列。左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。
  * **插入和删除操作：** `BST` 允许相对快速地执行插入和删除操作。通过维护树的结构，并根据节点值的大小关系进行调整，可以在平均情况下以 O(log n) 



### 二叉搜索树的优缺点

**优点**

* 高效的查找：`BST` 的结构使得查找操作高效，平均情况下时间复杂度为 O(log n)，其中 n 是节点数量。
* 高效的插入和删除： 在大部分情况下，插入和删除操作的时间复杂度也为 O(log n)，使得动态数据集的维护更为高效。
* 自然的排序：`BST` 的结构使得它天然具有排序性质，中序遍历 `BST` 可以得到有序的节点序列。



**缺点**

* 可能的不平衡性：在某些情况下，`BST` 可能会出现不平衡的情况，即树的高度会退化为接近线性，这会导致查找、插入和删除操作的最坏情况时间复杂度为 O(n)，而非理想的 O(log n)。
* 对于特定数据集效率不佳：如果数据集的顺序已经排好或者是逆序的，`BST` 的性能可能会大幅下降，因为它可能退化为链表形式，导致所有操作的时间复杂度都较高。



### 生活中对应的场景

* 文件系统：在文件系统中，可以使用二叉树来存储目录和文件的关系。 

* 检索数据：二叉搜索树是一种特殊的二叉树，**可以用于快速检索数据**。



## 二叉搜索树

### 接口设计

```java
public class BinarySearchTree<E> {

    // 元素的数量
    public int size() {}

    // 数组是否为空
    public boolean isEmpty() {}

    // 添加元素
    public void add(E element) {}

    // 删除指定位置元素
    public void remove(E element) {}

    // 清除所有元素
    public void clear() {}

    // 是否包含某个元素
    public boolean contains(E element) {} 
    
}
```



### 代码实现





### 单元测试





### 实战练习
