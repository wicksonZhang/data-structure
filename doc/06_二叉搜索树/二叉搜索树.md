# 二叉搜索树

> 本章节的代码：https://github.com/wicksonZhang/data-structure/tree/main/6-BST

## 基础知识

### 什么是二叉搜索树

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312010951236.png" alt="image-20231201095154187" style="zoom:80%;float:left" />

* 二叉搜索树（Binary Search Tree，`BST`）：二叉搜索树是二叉树的一种，二叉搜索树中每个节点中最多有两个子节点：左子节点和右子节点。
  * 其中任意一个节点的值都要 **大于** 其左子树所有节点的值
  * 其中任意一个节点的值都要 **小于** 其右子树所有节点的值
  * 它的左右子树也是一颗二叉搜索树

* 注意：二叉搜索树中存储的元素必须具备可比较性，且不允许为 null



### 二叉搜索树解决了什么问题

* 如果从数组的角度进行考虑，数组如果添加、删除、查找元素的话，最好可能是O（1），最坏的情况可能是O（n），平均是O（n）。
* 但二叉搜索树就进一步的解决了这个问题：
  * **高效查找**：由于其有序性质，可以利用二分搜索的方式快速定位到所需的节点，平均时间复杂度为 O(log n)。
  * **有序性：** `BST` 中的节点按照特定的顺序排列。左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。
  * **插入和删除操作：** `BST` 允许相对快速地执行插入和删除操作。通过维护树的结构，并根据节点值的大小关系进行调整，可以在平均情况下以 O(log n) 



### 二叉搜索树的优缺点

**优点**

* 高效的查找：`BST` 的结构使得查找操作高效，平均情况下时间复杂度为 O(log n)，其中 n 是节点数量。
* 高效的插入和删除： 在大部分情况下，插入和删除操作的时间复杂度也为 O(log n)，使得动态数据集的维护更为高效。
* 自然的排序：`BST` 的结构使得它天然具有排序性质，中序遍历 `BST` 可以得到有序的节点序列。



**缺点**

* 可能的不平衡性：在某些情况下，`BST` 可能会出现不平衡的情况，即树的高度会退化为接近线性，这会导致查找、插入和删除操作的最坏情况时间复杂度为 O(n)，而非理想的 O(log n)。
* 对于特定数据集效率不佳：如果数据集的顺序已经排好或者是逆序的，`BST` 的性能可能会大幅下降，因为它可能退化为链表形式，导致所有操作的时间复杂度都较高。



### 生活中对应的场景

* 文件系统：在文件系统中，可以使用二叉树来存储目录和文件的关系。 

* 检索数据：二叉搜索树是一种特殊的二叉树，**可以用于快速检索数据**。



## 二叉搜索树

### 接口设计

```java
public class BinarySearchTree<E> {

    // 元素的数量
    public int size() {}

    // 数组是否为空
    public boolean isEmpty() {}

    // 添加元素
    public void add(E element) {}

    // 删除指定位置元素
    public void remove(E element) {}

    // 清除所有元素
    public void clear() {}

    // 是否包含某个元素
    public boolean contains(E element) {} 
    
}
```



### 代码实现

#### 初始化成员变量

```java
public class BinarySearchTree<E> {
    
	private int size;

    private Node<E> root;

    /**
     * 初始化节点信息
     *
     * @param <E> 节点
     */
    private static class Node<E> {
        // 元素
        E element;

        // 右子节点
        Node<E> rightNode;

        // 左子节点
        Node<E> leftNode;

        // 父级节点
        Node<E> parentNode;

        public Node(E element, Node<E> parentNode) {
            this.element = element;
            this.parentNode = parentNode;
        }
    }
    
    // TODO

}
```

#### 初始化构造器

> 注意：由于二叉搜索树中必须遵循两个值具备可比较性。针对这种情况我们采用了两种解决方案：
>
> * 创建类并实现 `Comparable` 接口：`class Person implements Comparable<Person>`
> * 自定义实现规则并实现 `Comparator` 接口：`new BinarySearchTree<>(Comparator.comparingInt(Person::getAge))`

```java
public class BinarySearchTree<E> {
    
	private final Comparator<E> comparator;

    public BinarySearchTree() {
        this(null);
    }

    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator;
    }
    
}
```

#### 元素的数量

```java
    /**
     * 元素的数量
     *
     * @return int
     */
    public int size() {
        return size;
    }
```

#### 是否为空

```java
    /**
     * 是否为空
     *
     * @return boolean
     */
    public boolean isEmpty() {
        return size == 0;
    }
```

#### 添加元素

> 添加元素可能需要考虑的问题较多，而是二叉搜索树中必须满足如下两个条件
>
> * 二叉搜索树中存储的元素必须具备可比较性，且不允许为 null。
> * 二叉搜索树中左子节点的值必须要比当前节点小，右子节点的值必须比当前节点大。

* 例如，下图中当根节点为空时，当前新添加的元素就是根节点。

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071408422.gif" alt="动画" style="zoom:100%;float:left" />

* 例如，下图中当根节点不为空时，我们需要添加元素为 1 和元素为 12 的节点。

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071354290.gif" alt="动画" style="zoom:100%;float:left" />

实现思路：

* `Step1`：判断当前节点是否为 `root` 根节点，如果是根节点直接进行插入。
* `Step2`：如果不为根节点，则找到当前元素需要添加的父级节点，如果小于则在左边，大于则在右边，等于则进行覆盖。
* `Step3`：通过找到的父级节点于当前元素比较的大小来判断，是添加在父级节点的左边还是右边。
* **注意：** 我们需要注意我们对元素进行比较时需要考虑两种情况。分别是 `Comparator`、`Comparable` 两种方式。

```java
    /**
     * 添加元素
     *
     * @param element 元素
     */
    public void add(E element) {
        // 参数检查
        checkedElementNotNull(element);

        // Step1：如果当前的父级节点为 null ，则代表添加第一个元素
        if (root == null) {
            root = new Node<>(element, null);
            size++;
            return;
        }

        // Step2：如果当前节点不是父级节点，那就需要找到父级节点
        Node<E> node = root;
        Node<E> parent = root;
        int cmp = 0;
        // 将传递进来的元素与父级节点进行比较
        while (node != null) {
            cmp = compare(element, node.element);
            parent = node;
            if (cmp > 0) {
                node = node.rightNode;
            } else if (cmp < 0) {
                node = node.leftNode;
            } else {
                node.element = element;
                return;
            }
        }

        // Step3：我们将需要添加的元素添加在父级节点的那个位置
        Node<E> newNode = new Node<>(element, parent);
        if (cmp > 0) {
            parent.rightNode = newNode;
        } else {
            parent.leftNode = newNode;
        }
        size++;
    }
```

* compare 比较器

```java
    /**
     * 比较两个元素的大小
     * Comparator: java.util.Comparator
     * Comparable: java.lang.Comparable
     *
     * @param element1 元素1
     * @param element2 元素2
     * @return int
     */
    @SuppressWarnings("unchecked")
    private int compare(E element1, E element2) {
        if (comparator != null) {
            return comparator.compare(element1, element2);
        }
        return ((Comparable<E>) element1).compareTo(element2);
    }
```



#### 二叉搜索树的遍历

> 二叉搜索树的遍历主要分为以下四种：
>
> * 前序遍历（`Preorder Traversal`）
> * 中序遍历（`Inorder Traversal`）
> * 后序遍历（`Postorder Traversal`）
> * 层序遍历（`Level Order Traversal`）

##### 前序遍历（`Preorder Traversal`）

* 访问顺序：前序遍历，先遍历根节点、前序遍历左子树、前序遍历右子树。
* 二叉搜索树节点顺序：7、4、9、2、5、8、11、1、3、10、12
* 下图的访问节点顺序：7、4、2、1、3、5、9、8、11、10、12

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071643801.png" alt="image-20231207164328741" style="zoom:60%;float:left" />

* 实现思路：我们可以采用递归直接进行遍历

```java
    /**
     * 前序遍历：根节点、前序遍历左子树、前序遍历右子树
     */
    public void preorderTraversal() {
        preorderTraversal(root);
    }

    private void preorderTraversal(Node<E> node) {
        if (node == null) {
            return;
        }
        System.out.println("node.element = " + node.element);
        preorderTraversal(node.leftNode);
        preorderTraversal(node.rightNode);
    }
```

##### 中序遍历（`Inorder Traversal`）

* 访问顺序：中序遍历，先遍历左子树、根节点、右子树。
* 二叉搜索树节点顺序：7、4、9、2、5、8、11、1、3、10、12
* 下图的访问节点顺序：1、2、3、4、5、6、7、8、9、10、11、12

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071706816.png" alt="image-20231207170645775" style="zoom:85%;float:left" />

* 实现思路：中序遍历也是基于递归进行实现

```java
    /**
     * 中序遍历：左子树、根节点、右子树
     */
    public void inorderTraversal() {
        inorderTraversal(root);
    }

    private void inorderTraversal(Node<E> node) {
        if (node == null) {
            return;
        }
        inorderTraversal(node.leftNode);
        System.out.println("node.element = " + node.element);
        inorderTraversal(node.rightNode);
    }
```

##### 后序遍历（Postorder Traversal）

* 访问顺序：后续遍历左子树、后序遍历右子树、根节点
* 二叉搜索树节点顺序：7、4、9、2、5、8、11、1、3、10、12
* 下图的访问节点顺序：1、2、3、5、4、8、10、12、11、9、7

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071737692.png" alt="image-20231207173715658" style="zoom:85%;float:left" />

* 实现思路：后序遍历也是基于递归进行实现

```java
    /**
     * 后序遍历: 后续遍历左子树、后序遍历右子树、根节点
     */
    public void postOrderTraversal() {
        postOrderTraversal(root);
    }

    private void postOrderTraversal(Node<E> node) {
        if (node == null) {
            return;
        }
        postOrderTraversal(node.leftNode);
        postOrderTraversal(node.rightNode);
        System.out.println("node.element = " + node.element);
    }
```

##### 层序遍历（Level Order Traversal）

* 访问顺序：从上到下、从左到右依次访问每一个节点
* 二叉搜索树节点顺序：7、4、9、2、5、8、11、1、3、10、12
* 下图的访问节点顺序：7、4、9、2、5、8、11、1、3、10、12

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202312071747969.png" alt="image-20231207174704933" style="zoom:85%;float:left" />

* 实现思路：层序遍历我们采用的是队列进行实现

```java
    /**
     * 层序遍历：从上倒下，从左到右
     */
    public void levelOrderTraversal() {
        levelOrderTraversal(root);
    }

    private void levelOrderTraversal(Node<E> node) {
        if (node == null) {
            return;
        }
        Queue<Node<E>> queue = new LinkedList<>();
        // 将根节点进行入队
        queue.offer(node);
        while (!queue.isEmpty()) {
            Node<E> newNode = queue.poll();
            System.out.print("newNode = " + newNode.element);
            if (node.leftNode != null) {
                queue.offer(node.leftNode);
            }
            if (node.rightNode != null) {
                queue.offer(node.rightNode);
            }
        }
    }
```







### 单元测试





### 实战练习
