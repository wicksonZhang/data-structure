# 哈希表

> 本章节代码

## 基础知识

### 哈希表解决了什么问题？

​		哈希表主要解决了在大规模数据集中快速查找元素的问题，哈希表通过映射可以将查询的时间复杂度维持在 O(1) 级别。

​		假设我们有一个存储学生信息的系统，每个学生都有一个唯一的学生ID。我们希望能够快速地通过学生ID检索到对应的学生信息，而不需要遍历整个数据集来查找。哈希表通过一个哈希函数将每个学生ID映射到数组的特定位置，这个位置就是该学生信息在数组中的存储位置。这样，我们就可以通过学生ID快速地定位到对应的数组位置，而不需要遍历整个数组。

<img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401222037741.png" alt="image-20240122203736651" style="zoom:60%;margin-left:50px" />



### 哈希表是什么？

​		哈希表（`Hash Table`）是一种数据结构，用于实现键值对之间的映射关系。它通过将键（key）通过哈希函数映射到一个特定的索引位置，然后在该位置存储相应的值（value）。这使得在搜索、插入和删除操作中能够快速地定位和访问数据，这也使得了哈希表是以空间来换取时间。

​		哈希表的关键特点如下：

* **哈希函数：**将键映射到索引的函数。良好设计的哈希函数能够最小化碰撞（collision）的概率，即不同的键映射到相同的索引位置的情况。
* **碰撞处理：** 当两个不同的键映射到相同的索引位置时，需要一种方法来处理碰撞。常见的方法有**链地址法**和**开放寻址法**。
* **数组（桶）：** 存储实际数据的位置。每个索引位置通常称为一个桶，可能存储一个或多个键值对，以处理碰撞。

 

### 哈希表优缺点

**优点**

1. **快速的查找、插入和删除操作：** 在平均情况下，哈希表的这些操作的时间复杂度为 O(1)，即常数时间。
2. **灵活的数据存储：** 可以存储任意类型的数据作为值，而键可以是几乎任何数据类型。

**缺点**

1. **碰撞可能导致性能下降：** 如果两个不同的键映射到相同的索引位置，就会发生碰撞。
2. **空间复杂度可能较高：** 在某些情况下，为了避免碰撞，可能需要分配更多的空间，导致空间复杂度相对较高。
3. **不适用于有序数据：** 哈希表不保持键值对的顺序，因此对于需要有序访问的情况，可能不是最佳选择。



## 哈希函数

* 哈希函数：将键映射到索引的函数，首先生成 key 的哈希值，再让 key 的哈希值跟数组的大小进行计算，得出相关的索引值。

* 如下是 `hash` 函数的计算公式

  * 计算方式一：`hash_code(key) % table.length;`

  ```java
  public int hash(Object key) {
      return hash_code(key) % table.length;
  }
  ```

  * **计算方式二(推荐方式)**：`hash_code(key) & (table.length - 1);`
  * 注意：数组的长度设计为 2 的幂（2^n）

  ```java
  public int hash(Object key) {
      return hash_code(key) & (table.length - 1);
  }
  ```

* 如下是相关例子

  | 方式       | 哈希Code         | 计算方式 | 数组长度     | 索引值       |
  | ---------- | ---------------- | :------: | ------------ | ------------ |
  | 计算方式一 | 十进制：202      |    %     | 十进制：16   | 十进制：10   |
  | 计算方式二 | 二进制：11001010 |    &     | 二进制：1111 | 二进制：1010 |

* 总结：良好的哈希值能够最小化碰撞（collision）的概率，减少哈希碰撞的次数，提升哈希性能。



## 哈希碰撞

* 哈希冲突也被称为哈希碰撞，指的是 2 个不同的 key 经过哈希函数计算出相同的结果。` key1 ≠ key2，hash(key1) = hash(key2)`

  <img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401222117148.png" alt="image-20240122211758112" style="zoom:100%;float:left" />

* 解决哈希碰撞的方法如下

  * 开放寻址法：按照一定的规则向其他地址探测，一直到找到空桶。
  * 在哈希法：设计多个哈希函数。
  * 链地址发：通过链表将同一 index 的元素串起来。



### 链地址法

* 链地址法(Separate Chaining)：通过链表将同一index的元素串起来。具体如下图

  <img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401222114103.png" alt="image-20240122211453061" style="zoom:100%;float:left" />

* 如下是 `JDK 1.8` 解决哈希冲突的方案

  * 首先，添加元素是需要判断当前哈希表容量是否大于 64 且 单链表的节点数量是否大于 8。
  * 然后，如果不满足上诉条件，哈希冲突时则采用单链表进行存储。如果满足上诉条件，则将链表转为红黑树。
  * 最后，当红黑树节点数量少到一定程度时，又会转为单向链表。

  <img src="https://cdn.jsdelivr.net/gh/wicksonZhang/static-source-cdn/images/202401222246155.png" alt="image-20240122224640122" style="zoom:100%;float:left" />